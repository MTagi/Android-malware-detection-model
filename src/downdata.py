import argparse
import os
import requests
import urllib.request
from concurrent.futures import ThreadPoolExecutor
from random import sample
import json
import multiprocessing
import sys
import traceback
from collections import defaultdict
from pathlib import Path
from typing import Dict, List, Union, Optional

import sklearn
import dgl
import joblib as J
import networkx as nx
import torch
from androguard.core.analysis.analysis import MethodAnalysis, Analysis
from androguard.core.api_specific_resources import load_permission_mappings
from androguard.misc import AnalyzeAPK, AnalyzeDex
from gensim.models import Word2Vec
import os
import requests
import urllib.request
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
import traceback
import numpy as np
import sys
from pickle import dump
from hashlib import sha512
from androguard.misc import AnalyzeAPK
import argparse
import os
import requests
import urllib.request
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
from androguard.core.bytecodes import apk
from androguard.core.bytecodes import dvm
from androguard.decompiler.dad import decompile
from androguard.core.analysis import analysis
from androguard.decompiler.decompiler import DecompilerDAD
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
from androguard.core.analysis.analysis import Analysis
from androguard.decompiler.decompiler import DecompilerDAD
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
from androguard.core.analysis.analysis import Analysis
from androguard.decompiler.decompiler import DecompilerJADX

from transformers import AutoTokenizer, AutoModel
import torch
tokenizer = AutoTokenizer.from_pretrained("microsoft/codebert-base")
model_code = AutoModel.from_pretrained("microsoft/codebert-base")
def embedding_code(s):
  code_tokens=tokenizer.tokenize(s)
  tokens = [tokenizer.cls_token] + code_tokens + [tokenizer.eos_token]
  tokens_ids=tokenizer.convert_tokens_to_ids(tokens)
  context_embeddings=model_code(torch.tensor(tokens_ids)[None,:])[0]
  sentence_embedding = context_embeddings.mean(dim=1)
  return sentence_embedding
#Gọi model Sentence Embeddings
from sentence_transformers import SentenceTransformer
model = SentenceTransformer("all-MiniLM-L6-v2")
import networkx as nx
def xuly(source_file: Path, dest_dir: Path):
  try:
        # Xây dựng đồ thị fcg
        _, _, dxg = AnalyzeAPK(source_file)
        cg=dxg.get_call_graph()

        #Xây dựng tập thuộc tính
        G = nx.DiGraph(cg)
        maps={}

        for node in G.nodes():
            try:
              chuoi= str(node.method.source())
              maps[node]=embedding_code(chuoi)
            except:
              try:
                chuoi= str(node.full_name)+" "+str(node.method.permission_api_name)
                maps[node]=torch.tensor(model.encode(chuoi))
              except:
                maps[node]=torch.tensor(model.encode(" "))


        nx.set_node_attributes(cg, maps, 'thuoctinh')
        cg = nx.convert_node_labels_to_integers(cg)
        dg = dgl.from_networkx(cg, node_attrs=['thuoctinh'])
        file_name = source_file.stem
        dest_dir = dest_dir / f'{file_name}.fcg'
        dgl.data.utils.save_graphs(str(dest_dir), [dg])
  except Exception as e:
        print(f"Error while processing {source_file}")
        traceback.print_exception(*sys.exc_info())
        return
def download(sha256):
    try:
        base_url = 'https://androzoo.uni.lu/api/download?apikey=26fe85459ada965ec9fea79fa1e8a9e8e5ed2b39ae82e4a09b978f4ad84adc8c&sha256='
        url = base_url + sha256
        r = requests.get(url=url)

        if r.status_code == 200:
            link2apk = './sample_data/' + sha256 + '.apk'
            print(sha256 + " dealing")
            urllib.request.urlretrieve(url, link2apk)
            print('Downloaded APK:', sha256)
            # Ở đây đường dẫn là folder chứa file
            xuly(Path(link2apk), Path("/content/drive/MyDrive/dataabtm/khongdoc"))

            print(sha256 + " dealed")
            os.remove(link2apk)
            print('Deleted APK:', sha256)

    except Exception as e:
        print(f"Error in download_and_process({sha256}): {e}")
        traceback.print_exc()
#Link chứa đường dẫn của file muốn tải về.
file_path = os.path.abspath("/content/drive/MyDrive/dataabtm/link/khongdoc/data0.txt")
with open(file_path, 'r') as f:
    urls = [line.rstrip() for line in f.readlines()][0:]
num_threads = 10 # Using only one thread for sequential processing
with ThreadPoolExecutor(max_workers=num_threads) as executor:
    executor.map(download, urls)